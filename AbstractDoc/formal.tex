%!TEX root = main.tex

An attempt to give the most abstract possible definition of a blockchain.

\section{BlockChain}
Given a set $S$, let $\flist(S)$ and $\fset(S)$ be the sets of all finite lists and all finite sets of elements of $S$, respectively. Given $L \in \flist(S)$, we use notation $|L|$ to refer to the number of elements in $L$, and notation $L[i]$ to refer to the $i$-th element in $L$, where $i \in \{1, \ldots, |L|\}$. From now on, assume that $\Sigma$ is a finite alphabet, and that $\B \subseteq \Sigma^*$ is the set of all possible blocks. 
\begin{mydef}
A validation rule is a function $V : \flist(\B) \to \fset(\B)$
\end{mydef}
Intuitively $V$ is a function taking a list $L$ of block as input, and returning the set of blocks that could be added to $L$ to produce a valid blockchain.

\begin{mydef}
Let $G \in \flist(\B)$ be non-empty, and $V$ be a validation rule. Then a function $f : \{1, \ldots, n\} \rightarrow \B$ with $n \in \mathbb{N}$ is a validated chain with respect to $(G,V)$ if:
\begin{enumerate}
\item $|G| \leq n$ and $f(i) = G[i]$, for every $i \in \{1, \ldots, n\}$.

\item $f(1) \in V([\ ])$ and $f(i+1) \in V([f(1), \ldots, f(i)])$, for every $i \in \{1, \ldots, i-1\}$.
\end{enumerate}
\end{mydef}
Function $f$ in this definition is a valid chain according to the validation rule $V$ and the lists $G$ of genesis blocks (whose role is to provide the blocks to startup the system). Let $\LOG(G,V)$ be the set of validated chains with respect to $(G,V)$.

%\begin{myrem}
%	We introduce $LOG_{G,V}$ which really complicated but is actually necessary to deal with fork and consensus later.
%\end{myrem}
%
%\begin{mydef}
%	A set of validated chain $LOG_{G,V}$ is said to be infinite if:
%	$$\forall log_{G,V} \in LOG_{G,V}, \forall i \in \mathbb{N} , \forall b  \in V(log_{G,V}(i)-), V(log_{G,V}(i)-,b)\neq \emptyset $$
%\end{mydef}
%
%\begin{myrem}
%	Infinite here is used in a sense that whatever instance of a $G,V$ validated-chain we are dealing with we will always be able to complete it.
%\end{myrem}

\begin{mydef}
Let $G \in \flist(\B)$ be non-empty, and $V$ be a validation rule. Then $\LOG(G,V)$ is safe if for every $f \in \LOG(G,V)$ such that $f : \{1, \ldots, n\} \to \B$, and every $b_1, b_2 \in \B$ such that $b_1 \neq b_2$:
\begin{eqnarray*}
V([f(1), \ldots, f(n), b_1]) \cap V([f(1), \ldots, f(n), b_2]) & = & \emptyset
\end{eqnarray*}
\end{mydef}
Intuitively, in order to be secured $V$ should depend on the last block $b$ that is included in the blockchain.

\begin{mynota}
	For all $f : \{1, \ldots, n\} \rightarrow \B$ with $n \in \mathbb{N} \in LOG_{G,V}$ we denote $$f^L = [f(1), \ldots, f(n)]$$
\end{mynota}

\begin{mydef}
Let $P$ be a set of players and $K_T$ a function :
$$K_{T} : P \times \llbracket 0;T \rrbracket \times \mathbb{N} \rightarrow \fset(\B \times [0;1])$$ 
Then $(P,K_{T})$ is a valid knowledge representation if :

\begin{eqnarray*}
&\forall p \in P,\forall t\in \llbracket 0;T \rrbracket, (b,\alpha) \in K_{T}(t,0,p) \implies \alpha = 1 \lor \alpha = 0\\
&\forall p \in P,\forall t,t'\in \llbracket 0;T \rrbracket, t' \geq t, \forall b \in \B,  (b,1) \in K_{T}(t,0,p) \implies (b,1) \in K(t',0,p)  \\
&\forall p \in P,\forall t\in \llbracket 0;T \rrbracket, \forall \delta \in \mathbb{N}, \forall b \in \B,  (b,1) \in K_{T}(t,0,p) \implies (b,1) \in K(t,\delta,p) \\
&\forall p \in P,\forall t\in \llbracket 0;T \rrbracket, \forall \delta,\delta' \in \mathbb{N}, \delta' \geq \delta \implies \forall (b,\alpha) \in K_{T}(p,t,\delta), \exists (b,\alpha') \in K_{T}(p,t,\delta'), \alpha'\geq \alpha\\
\end{eqnarray*}
\end{mydef}

\begin{mynota}
	$\forall p \in P, \forall t\in \llbracket 0;T \rrbracket$ we denote $$K_{T}(p,t)=\{b | (b,1) \in K_{T}(p,t,0)\}$$
\end{mynota}

\begin{mydef}
	Let $T,T' \in \mathbb{N}$ such that $T>T'$ we say that $K'_{T'}$ extend $K_{T}$ if $$\forall p, K_{T}(p,T) = K'_{T'}(p,T)$$
\end{mydef}

\begin{mydef}
	A block chain protocol is a function noted $P_{G,V}$:
	$$P_{G,V} : \fset(LOG_{G,V}) \times \llbracket0,T\rrbracket \rightarrow \fset(LOG_{G,V}) $$
	such that :
\begin{eqnarray*}		
	\forall S, \forall t \in \llbracket0,T\rrbracket, P_{G,V}(S,t) \subseteq S
\end{eqnarray*}
\end{mydef}
\begin{myrem}
	$P_{G,V}$ can be seen as the rule in case of fork and new block. 
\end{myrem}

\begin{mydef}
	Considering $LOG_{G,V}$ the set of validated chains with respect to $(G,V)$, $(P,K_T)$ a valid knowledge representation and $P_{G,V}$ a block chain protocol. We denote $S_{t,p}$ where $t\in \llbracket0,T\rrbracket$ and $p\in P$ the set:
	$$ S_{t,p} = \{f | f \in LOG_{G,V} \land \forall i \in \{1, \ldots, |f^L|\}, f(i) \in K_T(p,t)\} $$
	
	We call a BlockChain at time $t\in \llbracket0,T\rrbracket$ for user $p \in P$ noted $BC_{t,p}$ a tuple:
	$$BC_{t,p} \in P_{G,V}(S_{t,p},t) $$
	
\end{mydef}
\begin{myrem}
	Intuitively the blockchain for a user $p$ at a time $t$ is one of the best chain he fully knows regarding the protocol function and the validity at time $t$ (time-stamping).
\end{myrem}

\begin{mydef}
	Considering $LOG_{G,V}$ the set of validated chains with respect to $(G,V)$, $(P,K_T)$ a valid knowledge representation.
	We denote $\alpha^*$ the function $$ \mathbb{N} \times LOG_{G,V} \times P \rightarrow [0,1]$$ such that : 
	$$\alpha^*(\delta,f,p) = max\{\alpha | \exists b \in \B; (b,\alpha) \in K_T(p,T,\delta)\cap V(f^L)\} $$
	We said that $LOG_{G,V}$ is alive regarding $(P,K_T)$ if:
	$$\exists p, \exists f, \forall  \in K_T(p,T) \land V(log_{G,V}(N)^-) \cap K_T(p,T) = \emptyset \land lim_{\delta\rightarrow \infty} \alpha^*(\delta,log_{G,V},N,p) = 1$$
\end{mydef}


\section{Draft}

\begin{mydef}
	We call an alive set of validated chain a tuple $(LOG_{G,V},P,K_P)$ where $LOG_{G,V}$ is an set of infinite validated chain and $P,K_P$ an alive set of player.
\end{mydef}

\begin{myprop*}
	Let $(LOG_{G,V},P,K_P)$ an alive set of validated chain then:
	$$\forall log_{G,V} \in LOG_{G,V}, \forall i \in \mathbb{N}, \exists p \in P, \exists t \in T , V(log_{G,V}(i)^-) \cap K_P(p,t) \neq \emptyset $$
\end{myprop*}
\begin{myrem}
	To be honest i am not sure as we are dealing with infinite number. I may have to trick things here. I want to ensure the fact that the chain will eventually move forward.
\end{myrem}
