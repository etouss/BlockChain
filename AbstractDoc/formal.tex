%!TEX root = main.tex

An attempt to give the most abstract possible definition of a blockchain.

\section{BlockChain}
\medskip
\noindent
\textbf{Chains as lists and their validation}

Given a set $S$, let $\flist(S)$ and $\fset(S)$ be the sets of all finite lists and all finite sets of elements of $S$, respectively. Given $L \in \flist(S)$, we use notation $|L|$ to refer to the number of elements in $L$, and notation $L[i]$ to refer to the $i$-th element in $L$, where $i \in \{1, \ldots, |L|\}$. From now on, assume that $\Sigma$ is a finite alphabet, and that $\B \subseteq \Sigma^*$ is the set of all possible blocks.  Moreover we extend the definition of $\subseteq$ such that :
\begin{eqnarray*}
	\forall S \in \fset(B), \forall L \in \flist(B), L \subseteq S \Leftrightarrow \forall i \in \{1, \ldots, |L|\}, L[i] \in S
\end{eqnarray*}

\begin{mydef}
A validation rule is a function $V : \flist(\B) \to \fset(\B)$
\end{mydef}
Intuitively $V$ is a function taking a list $L$ of block as input, and returning the set of blocks that could be added to $L$ to produce a valid blockchain.

\begin{mydef}
Let $G \in \flist(\B)$ be non-empty, and $V$ be a validation rule. Then a list $L \in \flist(\B)$ is a validated chain with respect to $(G,V)$ if:
\begin{enumerate}
\item $|G| \leq |L|$ and $L[i] = G[i]$, for every $i \in \{1, \ldots, |G|\}$.

\item $L[1] \in V([\ ])$ and $L[i+1] \in V([L[1], \ldots, L[i]])$, for every $i \in \{1, \ldots, |L|-1\}$.
\end{enumerate}
\end{mydef}
List $L$ in this definition is a valid chain according to the validation rule $V$ and the lists $G$ of genesis blocks (whose role is to provide the blocks to startup the system). Let $\LOG(G,V)$ be the set of validated chains with respect to $(G,V)$.

%\begin{myrem}
%	We introduce $LOG_{G,V}$ which really complicated but is actually necessary to deal with fork and consensus later.
%\end{myrem}
%
%\begin{mydef}
%	A set of validated chain $LOG_{G,V}$ is said to be infinite if:
%	$$\forall log_{G,V} \in LOG_{G,V}, \forall i \in \mathbb{N} , \forall b  \in V(log_{G,V}(i)-), V(log_{G,V}(i)-,b)\neq \emptyset $$
%\end{mydef}
%
%\begin{myrem}
%	Infinite here is used in a sense that whatever instance of a $G,V$ validated-chain we are dealing with we will always be able to complete it.
%\end{myrem}

\begin{mydef}
Let $G \in \flist(\B)$ be non-empty, and $V$ be a validation rule. Then $\LOG(G,V)$ is safe if for every $L \in \LOG(G,V)$ such that every $b_1, b_2 \in \B$ such that $b_1 \neq b_2$:
\begin{eqnarray*}
V([L[1], \ldots, L[|L|], b_1]) \cap V([L[1], \ldots, L[|L|], b_2]) & = & \emptyset
\end{eqnarray*}
\end{mydef}
Intuitively, in order to be secured $V$ should depend on the last block $b$ that is included in the blockchain.

\medskip
\noindent
\textbf{Knowledge}

\begin{mydef}
A \emph{knowledge tree} $K$ is a tree $K = (N,E)$ with $N \subseteq \B$ and such that 
every path in $K$ from its root to a leaf belongs to $LOG_{G,V}$.
Let $\mathcal{K}$ be the set of knowledge tree with respect to $(G,V)$.
\end{mydef}

Intuitively, the knowledge tree represents all the blockchain information we know. 
Abusing notation, we say that a block $B$ is in a knowledge tree $K = (N,E)$ if $B \in N$. 
(this is informal) We use $\paths(K)$ to denote the set of all lists of blocks made out of a path 
in $K$ from its root to a leaf. 


\medskip
\noindent
\textbf{Block chain, protocols}

\begin{mydef}
	Let $\preceq_{G,V,t}$ be  a total preorder over $LOG_{G,V}$:
\begin{eqnarray*}		
	&\forall L_1, L_2, L_3 \in LOG_{G,V}, L_1 \preceq_{G,V,t} L_2 \land L_2 \preceq_{G,V,t} L_3 \implies L_1 \preceq_{G,V,t} L_3  \\
	&\forall L_1, L_2 \in LOG_{G,V}, L_1 \preceq_{G,V,t} L_2 \lor L_2 \preceq_{G,V,t} L_1 
\end{eqnarray*}
	A block chain protocol over $LOG_{G,V}$ is a function noted $\preceq_{G,V}$ such that: $$ \forall t \in \mathbb{N}, \preceq_{G,V}(t) =  \preceq_{G,V,t}$$ where $\preceq_{G,V,t}$ is a total preorder over $LOG_{G,V}$
\end{mydef}

\begin{mydef}
Let $t \in \mathbb N$, $\preceq_{G,V}$ a block chain protocol and $K$ a knowledge tree. 
A block chain of $K$ with respect to $\preceq_{G,V}$ in $t$ is any minimal element in $\paths(K)$ with respect to $\preceq_{G,V}(t)$.
\end{mydef}

\begin{mydef}
	Let $K = (N,E)$ and $K'=(N',E')$ two knowledge trees we say that $K$ and $K'$ are $\equiv$ equivalent if :
	\begin{eqnarray*}
		& \equiv \textit{ is an equivalent function} \\
		& \forall L \in \paths(K), \exists L' \in \paths(K'), \forall i \in \llbracket 1,|L| \rrbracket, L[i] \equiv L'[i] \\
		& \forall L' \in \paths(K'), \exists L \in \paths(K), \forall i \in \llbracket 1,|L'| \rrbracket, L[i] \equiv L'[i] \\
	\end{eqnarray*}	
	We denote $K^{\equiv}$ the set of knowledge equivalent to $K$. 
\end{mydef}


\medskip
\noindent
\textbf{Action, states, reward and game}
\begin{mydef}
	Considering a set of player $P$ we denote $\mathcal{K}_P$ the set of function $K_P : P \rightarrow \mathcal{K}$ mapping a knowledge tree to each player. 
	We denote $\mathcal{K}^{\equiv}_P$ the set of mapping where:
	$$\forall K_P, K'_P \in \mathcal{K}^{\equiv}_P, \forall p \in P, K_P(p) \textit{ and } K'_P(p) \textit{ are } \equiv \textit{ equivalent } $$ 
\end{mydef}

Intuitively $\mathcal{K}_P$ represents the true knowledge of each player.

\begin{mydef}
	We call action a for player $w\in P$ function $a^\equiv_w: \mathcal{K}_P \rightarrow \mathcal{K}_P^{\equiv}$ such that: 
	\begin{eqnarray*}	
		&\forall K_P \in \mathcal{K}_P, \forall K'_P \in a_w(K_P),  \forall u \in P, K_P(u) \subseteq K'_P(u)  \\
		&\forall K_P \in \mathcal{K}_P, \forall K'_P \in a_w(K_P), \forall u \in P, K'_P(u) \subseteq K'_P(w) \cup K_P(u)  \\
	\end{eqnarray*}
	Let $A^\equiv_w$ be the set of action for player $w$.
\end{mydef}
An action of player $w$ is represented by a modification of $w$ knowledge and a round of communication. We are dealing with equivalence knowledge in order to reduce the number of action possible.

\begin{mydef}
	Let $P$ be a set of player, $\mathcal{A}^\equiv = A_{p_1}^\equiv \times A_{p_1}^\equiv \ldots \times A_{p_{|P|}}^\equiv$
\end{mydef}

\begin{mydef}
	We call reward for player $w$ a function $r_w : \mathcal{K}_P \times \mathcal{A}^\equiv \rightarrow \mathbb{R}^+$ 
	such that: $$ \forall A \in \mathcal{A}^\equiv, K_P \textit{ equivalent } K'_P \Rightarrow r_w(K_P,A) = r_w(K'_P,A) $$
\end{mydef}
Intuitively $\mathcal{K}_P$ represent the knowledge of each player assumed by $w$

\begin{mydef}
	Let $P$ be a set of player, $\mathcal{R} = r_{p_1} \times r_{p_1} \ldots \times r_{p_{|P|}}$
\end{mydef}
