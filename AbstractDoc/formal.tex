%!TEX root = main.tex

An attempt to give the most abstract possible definition of a blockchain.

\section{BlockChain}
Given a set $S$, let $\flist(S)$ and $\fset(S)$ be the sets of all finite lists and all finite sets of elements of $S$, respectively. Given $L \in \flist(S)$, we use notation $|L|$ to refer to the number of elements in $L$, and notation $L[i]$ to refer to the $i$-th element in $L$, where $i \in \{1, \ldots, |L|\}$. From now on, assume that $\Sigma$ is a finite alphabet, and that $\B \subseteq \Sigma^*$ is the set of all possible blocks. 
\begin{mydef}
A validation rule is a function $V : \flist(\B) \to \fset(\B)$
\end{mydef}
Intuitively $V$ is a function taking a list $L$ of block as input, and returning the set of blocks that could be added to $L$ to produce a valid blockchain.

\begin{mydef}
Let $G \in \flist(\B)$ be non-empty, and $V$ be a validation rule. Then a function $f : \{1, \ldots, n\} \rightarrow \B$ with $n \in \mathbb{N}$ is a validated chain with respect to $(G,V)$ if:
\begin{enumerate}
\item $|G| \leq n$ and $f(i) = G[i]$, for every $i \in \{1, \ldots, n\}$.

\item $f(1) \in V([\ ])$ and $f(i+1) \in V([f(1), \ldots, f(i)])$, for every $i \in \{1, \ldots, i-1\}$.
\end{enumerate}
\end{mydef}
Function $f$ in this definition is a valid chain according to the validation rule $V$ and the lists $G$ of genesis blocks (whose role is to provide the blocks to startup the system). Let $\LOG(G,V)$ be the set of validated chains with respect to $(G,V)$.

%\begin{myrem}
%	We introduce $LOG_{G,V}$ which really complicated but is actually necessary to deal with fork and consensus later.
%\end{myrem}
%
%\begin{mydef}
%	A set of validated chain $LOG_{G,V}$ is said to be infinite if:
%	$$\forall log_{G,V} \in LOG_{G,V}, \forall i \in \mathbb{N} , \forall b  \in V(log_{G,V}(i)-), V(log_{G,V}(i)-,b)\neq \emptyset $$
%\end{mydef}
%
%\begin{myrem}
%	Infinite here is used in a sense that whatever instance of a $G,V$ validated-chain we are dealing with we will always be able to complete it.
%\end{myrem}

\begin{mydef}
Let $G \in \flist(\B)$ be non-empty, and $V$ be a validation rule. Then $\LOG(G,V)$ is safe if for every $f \in \LOG(G,V)$ such that $f : \{1, \ldots, n\} \to \B$, and every $b_1, b_2 \in \B$ such that $b_1 \neq b_2$:
\begin{eqnarray*}
V([f(1), \ldots, f(n), b_1]) \cap V([f(1), \ldots, f(n), b_2]) & = & \emptyset
\end{eqnarray*}
\end{mydef}
Intuitively, in order to be secured $V$ should depend on the last block $b$ that is included in the blockchain.

\begin{mydef}
	We call player's knowledge a tuple $(P,K_{T})$ where $P$ is a set of player and $K_{T}$ a function:
	$$K_{T} : P\times [0;T] \times \mathbb{R}^+ \rightarrow \mathscr{P}(\Sigma^* \times ]0;1])$$
	such that: 
	\begin{align*}
	&\forall p \in P,\forall t\in [ 0;T ], (b,\alpha) \in K_{T}(t,0,p) \implies \alpha = 1 \\
	&\forall p \in P,\forall t,t'\in [ 0;T ], t' \geq t \implies K_{T}(t',0,p) \subseteq K(t,0,p)  \\
	&\forall p \in P,\forall t\in [ 0;T ], \forall \delta \in \mathbb{R}^+, K_{T}(t,0,p) \subseteq K_{T}(t,\delta,p) \\
	&\forall p \in P,\forall t\in [ 0;T ], \forall \delta,\delta' \in \mathbb{R}^+, \delta' \geq \delta \implies \forall (b,\alpha) \in K_{T}(p,t,\delta), \exists (b,\alpha') \in K_{T}(p,t,\delta'), \alpha'\geq \alpha\\
	\end{align*}
\end{mydef}

\begin{mynota}
	$\forall p \in P, \forall t\in [0;T]$ we denote $\{b | (b,1) \in K_{T}(p,t,0)\}$ : $K_{T}(p,t)$
\end{mynota}

\begin{mydef}
	Let $T,T' \in \mathbb{R}^+$ such that $T>T'$ we say that $K'_{T'}$ extend $K_{T}$ if $\forall p, K_{T}(p,T) = K'_{T'}(p,T)$
\end{mydef}

\begin{mydef}
	A block chain protocol is a function noted $P_{G,V}$:
	$$P_{G,V} : (LOG_{G,V}\times \mathbb{N})  \times (LOG_{G,V}\times \mathbb{N}) \times T \rightarrow (LOG_{G,V}\times \mathbb{N}) $$
	such that :
		\begin{align*}
		&\forall log_{G,V},log_{G,V}' \in LOG_{G,V}, \forall n,n' \in \mathbb{N} , \forall t \in T; P_{G,V}(log_{G,V},n,log_{G,V}',n',t) = (log_{G,V},n) \lor (log_{G,V},n')		\end{align*}
\end{mydef}
\begin{myrem}
	$P_{G,V}$ can be seen as the rule in case of fork and new block. 
	Have to be improve to impose that there is no cycle (an order ?)
\end{myrem}

\begin{mydef}
	Considering an validated chain $LOG_{G,V}$, a player's knowledge $(P,K_T)$ and a block chain protocol $P_{G,V}$. We denote $S_{t,p}$ where $t\in [0,T]$ and $p\in P$ the set of tuple :
	$$ S_{t,p} = \{log_{G,V}(N)^- | log_{G,V} \in LOG_{G,V} \land log_{G,V}(N)^- \subseteq K_T(p,t)\} $$
	
	We call BlockChain at time $t\in [0,T]$ for user $p \in P$ noted $BC_{t,p}$ the tuple:
	\begin{align*}
	&BC_{t,p} \in S_{t,p} \\
	& \forall log \in S_{t,p}, P_{G,V}((log,|log|),(BC_{t,p},|BC_{t,p}|),t) = (BC_{t,p},|BC_{t,p}|) \\
	\end{align*}
	
\end{mydef}
\begin{myrem}
	Intuitively the blockchain for a user $p$ at a time $t$ is the best chain he fully knows regarding the protocol function and the validity at time $t$ (time-stamping).
\end{myrem}

\begin{mydef}
	We denote $\alpha^*$ the function $$ \mathbb{R}^+ \times LOG_{G,V} \times N \times P \rightarrow [0,1]$$ such that : 
	$$\alpha^*(\delta,log_{G,V},N,p) = max\{\alpha | \exists b; (b,\alpha) \in K_T(p,T,\delta)\cap V(log_{G,V}(N)^-)\} $$
	We said that a $LOG_{G,V}$ is alive regarding $(P,K_T)$ iff:
	$$\exists p, \exists log_{G,V}, \exists N, log_{G,V}(N)^- \in K_T(p,T) \land V(log_{G,V}(N)^-) \cap K_T(p,T) = \emptyset \land lim_{\delta\rightarrow \infty} \alpha^*(\delta,log_{G,V},N,p) = 1$$
\end{mydef}


\section{Draft}

\begin{mydef}
	We call an alive set of validated chain a tuple $(LOG_{G,V},P,K_P)$ where $LOG_{G,V}$ is an set of infinite validated chain and $P,K_P$ an alive set of player.
\end{mydef}

\begin{myprop*}
	Let $(LOG_{G,V},P,K_P)$ an alive set of validated chain then:
	$$\forall log_{G,V} \in LOG_{G,V}, \forall i \in \mathbb{N}, \exists p \in P, \exists t \in T , V(log_{G,V}(i)^-) \cap K_P(p,t) \neq \emptyset $$
\end{myprop*}
\begin{myrem}
	To be honest i am not sure as we are dealing with infinite number. I may have to trick things here. I want to ensure the fact that the chain will eventually move forward.
\end{myrem}
