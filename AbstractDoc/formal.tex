%!TEX root = main.tex

An attempt to give the most abstract possible definition of a blockchain.

\section{BlockChain}
\medskip
\noindent
\textbf{Chains as lists and their validation}

Given a set $S$, let $\flist(S)$ and $\fset(S)$ be the sets of all finite lists and all finite sets of elements of $S$, respectively. Given $L \in \flist(S)$, we use notation $|L|$ to refer to the number of elements in $L$, and notation $L[i]$ to refer to the $i$-th element in $L$, where $i \in \{1, \ldots, |L|\}$. From now on, assume that $\Sigma$ is a finite alphabet, and that $\B \subseteq \Sigma^*$ is the set of all possible blocks.  Moreover we extend the definition of $\subseteq$ such that :
\begin{eqnarray*}
	\forall S \in \fset(B), \forall L \in \flist(B), L \subseteq S \Leftrightarrow \forall i \in \{1, \ldots, |L|\}, L[i] \in S
\end{eqnarray*}

\begin{mydef}
A validation rule is a function $V : \flist(\B) \to \fset(\B)$
\end{mydef}
Intuitively $V$ is a function taking a list $L$ of block as input, and returning the set of blocks that could be added to $L$ to produce a valid blockchain.

\begin{mydef}
Let $G \in \flist(\B)$ be non-empty, and $V$ be a validation rule. Then a list $L \in \flist(\B)$ is a validated chain with respect to $(G,V)$ if:
\begin{enumerate}
\item $|G| \leq |L|$ and $L[i] = G[i]$, for every $i \in \{1, \ldots, |G|\}$.

\item $L[1] \in V([\ ])$ and $L[i+1] \in V([L[1], \ldots, L[i]])$, for every $i \in \{1, \ldots, |L|-1\}$.
\end{enumerate}
\end{mydef}
List $L$ in this definition is a valid chain according to the validation rule $V$ and the lists $G$ of genesis blocks (whose role is to provide the blocks to startup the system). Let $\LOG(G,V)$ be the set of validated chains with respect to $(G,V)$.

%\begin{myrem}
%	We introduce $LOG_{G,V}$ which really complicated but is actually necessary to deal with fork and consensus later.
%\end{myrem}
%
%\begin{mydef}
%	A set of validated chain $LOG_{G,V}$ is said to be infinite if:
%	$$\forall log_{G,V} \in LOG_{G,V}, \forall i \in \mathbb{N} , \forall b  \in V(log_{G,V}(i)-), V(log_{G,V}(i)-,b)\neq \emptyset $$
%\end{mydef}
%
%\begin{myrem}
%	Infinite here is used in a sense that whatever instance of a $G,V$ validated-chain we are dealing with we will always be able to complete it.
%\end{myrem}

\begin{mydef}
Let $G \in \flist(\B)$ be non-empty, and $V$ be a validation rule. Then $\LOG(G,V)$ is safe if for every $L \in \LOG(G,V)$ such that every $b_1, b_2 \in \B$ such that $b_1 \neq b_2$:
\begin{eqnarray*}
V([L[1], \ldots, L[|L|], b_1]) \cap V([L[1], \ldots, L[|L|], b_2]) & = & \emptyset
\end{eqnarray*}
\end{mydef}
Intuitively, in order to be secured $V$ should depend on the last block $b$ that is included in the blockchain.

\medskip
\noindent
\textbf{Knowledge}

\begin{mydef}
A \emph{knowledge tree} $K$ is a tree $K = (N,E)$ with $N \subseteq \B$ and such that 
every path in $K$ from its root to a leaf belongs to $LOG_{G,V}$.
Let $\mathcal{K}$ be the set of knowledge tree with respect to $(G,V)$.
\end{mydef}

Intuitively, the knowledge tree represents all the blockchain information we know. 
Abusing notation, we say that a block $B$ is in a knowledge tree $K = (N,E)$ if $B \in N$. 
(this is informal) We use $\paths(K)$ to denote the set of all lists of blocks made out of a path 
in $K$ from its root to a leaf. 


\medskip
\noindent
\textbf{Block chain, protocols}

\begin{mydef}
	Let $\preceq_{G,V,t}$ be  a total preorder over $LOG_{G,V}$:
\begin{eqnarray*}		
	&\forall L_1, L_2, L_3 \in LOG_{G,V}, L_1 \preceq_{G,V,t} L_2 \land L_2 \preceq_{G,V,t} L_3 \implies L_1 \preceq_{G,V,t} L_3  \\
	&\forall L_1, L_2 \in LOG_{G,V}, L_1 \preceq_{G,V,t} L_2 \lor L_2 \preceq_{G,V,t} L_1 
\end{eqnarray*}
	A block chain protocol over $LOG_{G,V}$ is a function noted $\preceq_{G,V}$ such that: $$ \forall t \in \mathbb{N}, \preceq_{G,V}(t) =  \preceq_{G,V,t}$$ where $\preceq_{G,V,t}$ is a total preorder over $LOG_{G,V}$
\end{mydef}

\begin{mydef}
Let $t \in \mathbb N$, $\preceq_{G,V}$ a block chain protocol and $K$ a knowledge tree. 
A block chain of $K$ with respect to $\preceq_{G,V}$ in $t$ is any minimal element in $\paths(K)$ with respect to $\preceq_{G,V}(t)$.
\end{mydef}

\medskip
\noindent
\textbf{Action, incentive and game}
\begin{mydef}
	We call action a function $a: \mathcal{K} \rightarrow \mathcal{K}$ such that: 
	\begin{eqnarray*}	
		&\forall K \in \mathcal{K}, K \subseteq a(K) \\
		&\forall K \in \mathcal{K} , |a(K) \setminus K| \leq 1
	\end{eqnarray*}
	Let $A$ be the set of action.
\end{mydef}
The action represents the mining strategy we only capture valid mining strategy...  not sure if the second property is needed we could represent more complex strategy without it. Have to thinks about it.

\begin{myrem}
	In order to reach a finite number of action we might end up definition them over equivalence classes of $K$ (meaning a block B upon V(L) is equivalent to mine a block B' upon V(L) then the number of possible action for a player would be |Path(K)|). just an idea that i dont want to forget.
\end{myrem}



\begin{mydef}
	We call incentive a function $I : A \times \mathcal{K} \times P \rightarrow \mathbb{R}^+$ 
\end{mydef}
This incentive function will capture all the real world assumption such as, want money, destroy system ?,  50\% hpower etc ... reward will also rely on probability to sucess.


\begin{mydef}
	Considering a set of player $P$, a function $K_P : P \rightarrow \mathcal{K}$, the set of action $A$, and a incentive $I$. We define a strategic game such that:
	\begin{itemize}
		\item $P$ is the set of player.
		\item $\forall p \in P$, $A$ is the set of available action.
		\item $\forall p \in P, \forall a_1, a_2 \in A$ we say that $a_1$ is preferred to $a_2$ if $I(a_1,K_P(p),p) \geq I(a_2,K_P(p),p)$.
	\end{itemize}
\end{mydef}

Tweak definition a bit to reach finite game (doable if i touch to $A$) and proove equilibrium existence..

\begin{mydef}
	We say that $K'_P$ is reasonable if exists an action $a \in A$ associate to a player $w \in P$ in an equilibrium profile such that: 	\begin{eqnarray*}	
		& K'_P(w) = a(K_P(w)) \\
		&\forall p \in P, K_P(p) \subseteq K'_P(p) \\
		&\forall p \in P, K'_P(p) \subseteq K_P(p) \cup K'_P(w) \\
	\end{eqnarray*}	
	$K'_P$ represent all the possible knowledge after one reasonable action (on belonging to a nash equilibrium) has happened with an optional comunication round from the winner ($K'_P(p) \subseteq K_P(p) \cup K'_P(w)$). 
\end{mydef}

Good to go we finally have a defintion of reasonable $K$ and can define blockchain property which should be verified over all reasonable $K$.
