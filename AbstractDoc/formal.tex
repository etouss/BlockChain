%!TEX root = main.tex

An attempt to give the most abstract possible definition of a blockchain.

\section{BlockChain}

\subsection{Lists and their validation}

Given a set $S$, let $\set(S)$ be the set of sets of elements of $S$ and $\flist(S)$ be the set of all finite lists of elements of $S$. Given $L \in \flist(S)$, we use notation $\length(L)$ to refer to the number of elements in $L$, notation $L[i]$ to refer to the $i$-th element in $L$, where $i \in \{1, \ldots, \length(L)\}$, and notation $L[i,j]$ to refer to the sublist $[L[i], \ldots, L[j]]$ of $L$, where $i,j \in \{1, \ldots, \length(L)\}$ and $i \leq j$. Notice that $\length(L) = 0$ if and only if $L$ is the empty list $[\ ]$. Finally, we say that a list $L_1$ is a prefix of a list $L_2$ if $L_1$ is the empty list, or $1 \leq \length(L_1) \leq \length(L_2)$ and $L_1 = L_2[1, \length(L_1)]$. 

From now on, assume that $\Sigma$ is a finite alphabet, and that $\B \subseteq \Sigma^*$ is the set of all possible blocks.  
%MARCELO: Do we really need the following?
%Moreover we extend the definition of $\subseteq$ such that :
%\begin{eqnarray*}
%	\forall S \in \fset(B), \forall L \in \flist(B), L \subseteq S \Leftrightarrow \forall i \in \{1, \ldots, |L|\}, L[i] \in S
%\end{eqnarray*}

\begin{mydef}
	A validation rule is a function $V : \flist(\B) \to \set(\B)$
\end{mydef}
Intuitively, $V$ is a function taking a finite list $L$ of blocks as input, and returning the set of blocks that could be added to $L$ to produce a valid blockchain.

A list $G \in \flist(\B)$  is said to be a genesis list of $V$ if $\length(G) \geq 1$, $G[1] \in V([\ ])$ and $G[i+1] \in V(G[1,i])$, for every $i \in \{1, \ldots, \length(G)-1\}$. That is, $G$ is a genesis list if $G$ is a non-empty valid blockchain. 
\begin{mydef}
	Let $V$ be a validation rule and $G$ be a genesis list of $V$. Then a list $L \in \flist(\B)$ is valid with respect to $(G,V)$ if:
	\begin{enumerate}
		\item $\length(G) \leq \length(L)$ and $G = L[1,\length(G)]$.
		
		\item $L[i+1] \in V(L[1,i])$, for every $i \in \{\length(G), \ldots, \length(L)-1\}$.
	\end{enumerate}
\end{mydef}
The role of $G$ in this definition is to provide the blocks to startup the system. Let $\LOG(G,V)$ be the set of valid lists with respect to $(G,V)$.

%\begin{myrem}
%	We introduce $LOG_{G,V}$ which really complicated but is actually necessary to deal with fork and consensus later.
%\end{myrem}
%
%\begin{mydef}
%	A set of validated chain $LOG_{G,V}$ is said to be infinite if:
%	$$\forall log_{G,V} \in LOG_{G,V}, \forall i \in \mathbb{N} , \forall b  \in V(log_{G,V}(i)-), V(log_{G,V}(i)-,b)\neq \emptyset $$
%\end{mydef}
%
%\begin{myrem}
%	Infinite here is used in a sense that whatever instance of a $G,V$ validated-chain we are dealing with we will always be able to complete it.
%\end{myrem}

Two lists $L_1, L_2 \in \flist(\B)$ are said to disagree in the last element if one of the following conditions holds: (1) $\length(L_1) = 0$ and $\length(L_2) > 0$, (2) $\length(L_1) > 0$ and $\length(L_2) = 0$, or (3) $\length(L_1) > 0$, $\length(L_2) > 0$ and $L_1[\length(L_1)] \neq L_2[\length(L_2)]$.
\begin{mydef}
	Let $V$ be a validation rule and $G$ be a genesis list of $V$. Then $\LOG(G,V)$ is safe if for every pair $L_1, L_2 \in \flist(\B)$ that disagree in the last element, it holds that $V(L_1) \cap V(L_2) = \emptyset$.
\end{mydef}


\subsection{Body of knowledge}

In this document,  we will give a game-theoretic characterization of the notion of blockchain where it plays a key role the knowledge of each participant. More precisely, given a validation rule $V$ and a genesis list $G$ of $V$, a body of knowledge of $(G,V)$ is a non-empty and finite subset $K$ of $\LOG(G,V)$ satisfying the following closure property:
\begin{itemize}
\item if $L_1 \in \LOG(G,V)$, $L_1$ is a prefix of $L_2$ and $L_2 \in K$, then $L_1 \in K$.
\end{itemize}
Intuitively, if at some iteration a participant considers a list $L \in \LOG(G,V)$ as valid, then she should also consider as valid every prefix of $L$ including the genesis list, that is, every prefix of $L$ belonging to $\LOG(G,V)$. The set of bodies of knowledge of $(G,V)$ is denoted by $\BK(G,V)$. 

There is a natural way to  visualize a body of knowledge $K$ as a graph $\G(K)$. The set of nodes of $\G(K)$ is the set of blocks occurring in the lists in $K$, and there is an edge from a block $b_1$ to a block $b_2$ if there exists a list $L \in K$ such that $b_1 = L[i]$ and $b_2 = L[i+1]$, where $i \in \{1, \ldots, \length(L) -1\}$.
\begin{mylem}
	Assume that $\LOG(G,V)$ is safe. Then for every $K \in \BK(G,V)$, it holds that $\G(K)$ is a tree rooted at $G[1]$.
\end{mylem}

%\juan{Related to the next comment, why do we need $\K(G,V)$? this is just all non-empty finite subset $K$ of $\LOG(G,V)$}\\ 
%
%Thus, assuming that $\LOG(G,V)$ is safe, from now on we refer to every non-empty finite subset $K$ of $\LOG(G,V)$ as a {\em knowledge tree} of $(G,V)$. Moreover, we define $\K(G,V)$ as the set of all knowledge trees of $(G,V)$.

%A \emph{knowledge tree} $K$ is a tree $K = (N,E)$ with $N \subseteq \B$ and such that 
%every path in $K$ from its root to a leaf belongs to $LOG_{G,V}$.
%Let $\mathcal{K}$ be the set of knowledge tree with respect to $(G,V)$.

%Intuitively, the knowledge tree represents all the blockchain information we know. 
%Abusing notation, we say that a block $B$ is in a knowledge tree $K = (N,E)$ if $B \in N$. 
%(this is informal) We use $\paths(K)$ to denote the set of all lists of blocks made out of a path 
%in $K$ from its root to a leaf. 

\subsection{Protocols and blockchain}

\begin{mydef}
	A relation $\preceq$ on $\LOG(G,V)$ is said to be a knowledge order over $(G,V)$ if $\preceq$ is a total preorder on $\LOG(G,V)$, that is, $\preceq$ is reflexive, transitive and total.
	
	Moreover, a sequence $\{ \preceq_i\}_{i \in \mathbb{N}}$ is said to be a blockchain protocol over $(G,V)$ if every $\preceq_i$ $(i \in \mathbb{N})$ is a knowledge order over $(G,V)$.
\end{mydef}

%\begin{mydef}
%	Let $\preceq_{G,V,t}$ be  a total preorder over $LOG_{G,V}$:
%\begin{eqnarray*}		
%	&\forall L_1, L_2, L_3 \in LOG_{G,V}, L_1 \preceq_{G,V,t} L_2 \land L_2 \preceq_{G,V,t} L_3 \implies L_1 \preceq_{G,V,t} L_3  \\
%	&\forall L_1, L_2 \in LOG_{G,V}, L_1 \preceq_{G,V,t} L_2 \lor L_2 \preceq_{G,V,t} L_1 
%\end{eqnarray*}
%	A block chain protocol over $LOG_{G,V}$ is a function noted $\preceq_{G,V}$ such that: $$ \forall t \in \mathbb{N}, \preceq_{G,V}(t) =  \preceq_{G,V,t}$$ where $\preceq_{G,V,t}$ is a total preorder over $LOG_{G,V}$
%\end{mydef}


%\marcelo{Do we really need to use the notion of knowledge tree in the following definitions? If we say that $K$ is a knowledge tree then we need to use $\paths(K)$ to refer to the paths in $K$. On the other hand, if we directly say that $K \in \LOG(G,V)$, we can just refer to the elements of $K$ (we do not a special notation for paths). Knowledge trees are a nice way to visualize the blocks of set $K \in \LOG(G,V)$, but I think we should just mention them because of this (and we should not use them in the definitions). What do you think?}
%
%\juan{You mean $K \subset \LOG(G,V)$ right? I agree that here we do not need safeness nor finitiness to make this work, so we could just stick with $\LOG(G,V)$ instead of all knowledge trees}


\begin{mydef}
	Let $\{ \preceq_i\}_{i \in \mathbb{N}}$ be a blockchain protocol over $(G,V)$, $K \in \BK(G,V)$ and $t \in \mathbb{N}$. 
	Then a maximal element of $K$ with respect to $\preceq_t$ is said to be a blockchain of $K$ at iteration $t$ with respect to the protocol $\{ \preceq_i\}_{i \in \mathbb{N}}$.
\end{mydef}


%\marcelo{I stopped here. I am not totally convinced that we need to introduce the following notion of equivalence, this is something that we need to discuss.}


\subsection{Definition of the game}
Fix a validation rule $V$ and a genesis list $G$ of $V$. From now on, we assume that $\cP = \{1, \ldots, n\}$ is a finite set of players, and we say that a view $\bv$ is a tuple $(v_1, \ldots, v_n) \in \BK(G,V)^n$. Intuitively, each component $v_i$ of $\bv$ represents the knowledge of player $i$, so $\bv$ contains the knowledge of all the players. Moreover, we denote by $\cV$ the set of all possible views, that is, $\cV = \BK(G,V)^n$.

\marcelo{Notice that I am using bold font for tuples. Please use the same notation in the rest of the paper.}

%\begin{mydef}
%	Considering a set of player $P$ we denote $\mathcal{K}_P$ the set of function $K_P : P \rightarrow \mathcal{K}$ mapping a knowledge tree to each player. 
%	%We denote $\mathcal{K}^{\equiv}_P$ the set of mapping where:
%	%$$\forall K_P, K'_P \in \mathcal{K}^{\equiv}_P, \forall p \in P, K_P(p) \textit{ and } K'_P(p) \textit{ are } \equiv \textit{ equivalent } $$ 
%\end{mydef}

%Intuitively $\mathcal{K}_P$ represents the true knowledge of each player.

\begin{mydef}\label{def-action}
Given a player $p \in \cP$, a function $a : \cV \to \cV$ is an action for $p$ if
\begin{itemize}
\item for every $\bv \in \cV$ and $q \in \cP$, if $\bv = (v_1, \ldots, v_n)$ and $a(\bv) = (w_1, \ldots, w_n)$, then it holds that:
\begin{eqnarray*}
v_q \ \subseteq \ w_q \ \subseteq \ v_q \cup w_p.
\end{eqnarray*}

\end{itemize}
Moreover, $\cA_p$ is the set of all actions for player $p$.
\end{mydef}
An action of a player $p$ is represented by a modification of the knowledge of $p$ and a round of communication between players. 

If we need to restrict the number of blocks that can be added when an action is executed (like in the case of Bitcoin), then we need to include in Definition \ref{def-action} a condition like the following:
\begin{itemize}
\item for every $\bv \in \cV$, if $\bv = (v_1, \ldots, v_n)$ and $a(\bv) = (w_1, \ldots, w_n)$, then it holds that $|w_p| \leq |v_p| + 1$.
\end{itemize}
In this case, at most one block can be added as the result of executing action $a$ by player $p$. 

From now on, assume that $\cA = \cA_{1} \times \cA_{2} \times \cdots \times \cA_{n}$. Thus, every element of $\ba \in \cA$ is a tuple containing exactly one action for each player. Moreover, given a player $p \in \cP$, a function $r_p : \cV \times \cA \to \mathbb{R}$ is called a reward function for $p$. Intuitively, given the knowledge of each player, encoded as a view $\bv$ in $\cV$, and the actions executed by each player, encoded as a tuple $\ba$ in $\cA$, function $r_p$ tell us what the reward of player $p$ is if the state of the world is $v$ and the tuple of actions $\ba$ is executed. Finally, assuming that there is a reward function $r_p$ for each player $p \in \cP$, define $\cR = (r_1, \ldots, r_n)$ as the reward function of the game.

As a last component of the game, we assume that $\pr : \cV \times \cA \times \cV \to [0,1]$ is a function such that 
for every $\bv \in \cV$ and $\ba \in \cA$:
\begin{eqnarray*}
\sum_{\bw \in \cV} \pr(\bv, \ba, \bw) & = & 1
\end{eqnarray*}
Intuitively, $\pr(\bv, \ba, \bw)$ tell us what the probability of modifying $\bv$ to generate $\bw$ is when the tuple of actions $\ba$ is executed.

Then $\Gamma = (\cP,\cA,\cV,\cR,\pr)$ is an infinite stochastic game where :
\begin{itemize}
	\item $\cP$ is the set of player.
	\item $\cA$ is the set of available action.
	\item $\cV$ is the set of states.
	\item $\cR$ the set of pay-off function.
	\item $\pr$ is the transition probability function.
\end{itemize} 


\subsection{Stationary equilibrium}

\begin{mydef}
	We call stationary strategy for a player $p$ a function $s : \cV \rightarrow \cA_p$ 
	Moreover $\cS_p$ is the set of all strategy for player $p$. 
\end{mydef}


From now on, assume that $\cS = \cS_{1} \times \cS_{2} \times \cdots \times \cS_{n}$. Thus, every element of $\bs \in \cS$ is a tuple containing exactly one strategy for each player.

Considering a view $\bv \in \cV$ and $\bs \in \cS$ we denote $\bs(\bv)$ the action vector $(s_{1}(\bv),\ldots,s_{n}(\bv)) \in \cA$ 
\begin{myprop}
	Considering a game $\Gamma$ and a stationary strategy vector $\bs \in \cS$, 
	the probability to reach a view $\bv \in \cV$ in $n$ step called $n$-reachability probability noted $\mathcal{P}^\bs_n : \cV \rightarrow [0;1]$ is computed by induction :
	$$\mathcal{P}^\bs_0(\bv) = \left\{\begin{array}{ll}
	1 & \mbox{if } \bv = \bv_0 \\
	0 & \mbox{otherwise}
	\end{array}\right.$$
	$$\mathcal{P}^\bs_{n+1}(\bv) = \sum_{\bv' \in \cV} \mathcal{P}^\bs_{n}(\bv') * \pr(\bv',\bs(\bv'),\bv)$$
	%We say that $\bv$ is $\bs$ reachable if exists $n \in \mathcal{N}$ such that $\mathcal{P}^\bs_{n}(\bv) > 0$
\end{myprop}

\begin{proof}
	immediate.
\end{proof}


\begin{mydef}
	Let $\beta \in [0,1]$, we call $\beta$ discounted reward of player $p \in \cP$ for a strategy vector $\bs \in \cS$ and a game $\Gamma$ the value 
	$$u_p(\bs) = 	\sum_{n=0}^{+\infty}\beta^{n+1} *  (\sum_{\bv\in\cV} r_p(\bv,\bs(\bv))*\pr(\bv,\bs(\bv),s_p(\bv))*\mathcal{P}^\bs_{n}(\bv)) $$
\end{mydef}

Considering $p \in \cP$, $\bs \in \cS$ and $s'\in \cS_p$ we denote $(\bs_{\neg p}, s')$ the strategy vector $(s_1, \ldots s_{p-1},s',s_{p+1}, \ldots, s_{n})$.
\begin{mydef}
	We say that $\bs \in \cS$ is a $\beta$ discounted stationary equilibrium of $\Gamma$ iff : 
	$$\forall p \in \cP, \forall s' \in \cS_p,  u_p(\bs) \geq u_p((\bs_{\neg p},s')) $$
\end{mydef}

\subsection{Properties of a blockchain}

\begin{mylem}
	Considering a game $\Gamma$ and a stationary strategy vector $\bs \in \cS$, 
	the probability to reach an element of a set of view $\bV \in \set(\cV)$  without walking by an element of $\bV' \in \set(\cV)$ in $n$ steps noted $\mathcal{P}^{\bs+}_n : \set(\cV) \times \set(\cV) \rightarrow [0;1]$ is computed by induction :
	$$\mathcal{P}^{\bs+}_0(\bV,\bV') = \left\{\begin{array}{ll}
	1 & \mbox{if } \bv_0 \in \bV \\
	0 & \mbox{otherwise}
	\end{array}\right.$$
	
	$$\mathcal{P}^{\bs+}_{n+1}(\bV,\bV') = \sum_{\bw \in \cV \setminus \bV'}   [\mathcal{P}^{\bs+}_{n}(\{\bw\},\bV') * \sum_{\bv \in \bV}^{}\pr(\bw,\bs(\bw),\bv) ]$$
	%We say that $\bv$ is $\bs$ reachable if exists $n \in \mathcal{N}$ such that $\mathcal{P}^\bs_{n}(\bv) > 0$
\end{mylem}

\begin{proof}
	to do.
\end{proof}

\begin{mylem}
	Considering a game $\Gamma$ and a stationary strategy vector $\bs \in \cS$, 
	the probability to reach an element of a set of view $\bV \in \set(\cV)$ for the first time in $n$-step is equal to $\mathcal{P}^{\bs+}_n(\bV,\bV)$
\end{mylem}

\begin{proof}
	immediate.
\end{proof}

\begin{myprop}
	Considering a game $\Gamma$ and a stationary strategy vector $\bs \in \cS$, 
	the probability to reach an element of a set of view $\bV \in \set(\cV)$ noted  $\mathcal{P}^{\bs} : \set(\cV) \rightarrow [0;1]$ is equal to $$\mathcal{P}^{\bs}(\bV) = \sum_{n=0}^{+\infty}\mathcal{P}^{\bs+}_n(\bV,\bV)$$
\end{myprop}

\begin{proof}
	to do.
\end{proof}

\begin{mydef}
	Let $P$ be a property over a view, let $\bv \in \cV$ we denote $\bv \vdash P$ if $\bv$ satisfies the property $P$. Let $\bV \in \set(\cV)$ we denote $\bV \vdash P$ if and only if $\forall \bv \in \bV, \bv \vdash P$.
\end{mydef}

\begin{mydef}
	Considering $(G,V)$, $\{ \preceq_i\}_{i \in \mathbb{N}}$ a blockchain protocol over $(G,V)$ and $\Gamma = (\cP,\cA,\cV,\cR,\pr)$ a stochastic game. We say that a property $P$ is verified by $(G,V)$, $\{ \preceq_i\}_{i \in \mathbb{N}}$ regarding $\Gamma$ with a probability $\alpha$ if and only if:
	\begin{itemize}
		\item Exists a $\beta$ discounted stationary equilibrium of $\Gamma$ \\
		\item Forall $\beta$ discounted stationary equilibrium of $\Gamma$ $\bs \in \cS $ for every set of view $\bV \in \cV$ we have $$\mathcal{P}^{\bs}(\bV) \geq \alpha \implies \bV \vdash  P $$ 
	\end{itemize}
\end{mydef}


\section{Block Equivalence}

\subsection{Equivalent Body of knowledge}

\begin{mydef}
	Given a validation rule $V$, a genesis list $G$ of $V$ and an equivalence relationship $\equiv$ over $\B$. We say that $K_1 \in \BK(G,V)$ and $K_2 \in \BK(G,V)$ are $\equiv$ equivalent if and only if:
	\begin{eqnarray*}
		& \forall L_1 \in K_1, \exists L_2 \in K_2, \forall i \in \llbracket 1,|L_1| \rrbracket, L_1[i] \equiv L_2[i] \\
		& \forall L_2 \in K_2, \exists L_1 \in K, \forall i \in \llbracket 1,|L_2| \rrbracket, L_1[i] \equiv L_2[i] \\
	\end{eqnarray*}	
	By extension we denote $K_1 \equiv K_2$ resp. $L_1 \equiv L_2$ when two body knowledge resp. list are $\equiv$ equivalent.
\end{mydef}
We denote $\BK^\equiv(G,V)$ the set of equivalence classes of $\BK(G,V)$


\begin{mydef}
	Given a validation rule $V$, a genesis list $G$ of $V$ and $\{ \preceq_i\}_{i \in \mathbb{N}}$ a blockchain protocol over $(G,V)$ we say that an equivalence relationship $\equiv$ over $\B$ is $\{ \preceq_i\}_{i \in \mathbb{N}}$ compatible if and only if:
	$$\forall K_1 , K_2 \in \BK(G,V)$$
	$$K_1 \equiv K_2 \implies \forall i \in \mathbb{N}, \forall L_1 \in \{L | L \in K_1, \forall L' \in K_1, L' \preceq_i L \}, \exists L_2 \in \{L | L \in K_2, \forall L' \in K_2, L' \preceq_i L \}, L_1 \equiv L_2$$
\end{mydef}


\subsection{Game with equivalence}

For now on we consider a game $\Gamma = (\cP,\cA,\cV,\cR,\pr)$ associated to  a validation rule $V$ a genesis list $G$ and a blockchain protocol $\{ \preceq_i\}_{i \in \mathbb{N}}$. 

We say that two view $\bv_1, \bv_2 \in \cV$ are equivalent regarding $\equiv$ a equivalent relationship over $\B$ noted $\bv_1\equiv \bv_2$ if $$\forall p \in \cP, v_{1p} \equiv v_{2p}$$

We denote $\cV^\equiv$ the set of equivalence classes of $\cV$

\begin{mydef}
	Let $\equiv$ a equivalence relationship over $\B$ we say that $\equiv$ is $\cA$ compatible if $\forall p \in \cP$ and $\forall a \in \cA_p$ we have $$\forall \bv_1,\bv_2 \in \cV, \bv_1 \equiv \bv_2 \implies a(\bv_1) \equiv a(\bv_2 )$$
\end{mydef}

\begin{mydef}
	Let $p \in \cP$,considering $a_1, a_2 \in \cA_p$ and $\equiv$ a equivalence relationship $\cA$ compatible we say that $a_1$ and $a_2$ are equivalent noted $a_1 \equiv a_2$ if and if:
	$$\forall \bv_1,\bv_2 \in \cV, \bv_1 \equiv \bv_2 \implies a_1(\bv_1) \equiv a_2(\bv_2)$$
\end{mydef}
We denote $\cA^\equiv_p$ the set of equivalence classes of $\cA$ then a element of $\cA^\equiv_p$ is a function $$a^\equiv : \cV^\equiv \rightarrow \cV^\equiv$$.

\begin{myprop}
	Let $p \in \cP$, $\equiv$ a equivalence relationship $\cA$ compatible and $a^\equiv \in \cA^\equiv_p $ then
	\begin{itemize}
		\item for every $\bv^\equiv \in \cV^\equiv$ and $q \in \cP$, if $\bv^\equiv = (v_1^\equiv, \ldots, v_n^\equiv)$ and $a^\equiv(\bv^\equiv) = (w_1^\equiv, \ldots, w_n^\equiv)$, then it holds that:
		\begin{eqnarray*}
			\forall v_q \in v_q ^\equiv,\forall w_q \in w_q ^\equiv,\forall w_p \in w_p ^\equiv,  v_q \ \subseteq \ w_q \ \subseteq \ v_q \cup w_p.
		\end{eqnarray*}
	\end{itemize}
\end{myprop}

\begin{proof}
	to do.
\end{proof}


\begin{myprop}
	Let $p \in \cP$, and $\equiv$ a $\cA$ compatible equivalence relationship over $\B$
	then the function $\pr^\equiv : \cV^\equiv \times \cA^\equiv \times \cV^\equiv \rightarrow [0,1]$ such that: 
	$$\pr^\equiv(\bv^\equiv,\ba^\equiv,\bw) = \sum_{\ba \in \ba^\equiv}\pr(\bv,\ba,\bw) \mbox{ where : } \bv\in \bv^\equiv \mbox{ and } \bw \in \bw^\equiv$$ 
	is well defined and 
	$$\forall \bv^\equiv \in \cV^\equiv,\forall \ba \in \cA^\equiv, \sum_{\bw ^\equiv \in \cV^\equiv} \pr^\equiv(\bv^\equiv, \ba^\equiv, \bw^\equiv)  =  1 $$
\end{myprop}
\begin{proof}
	to do.
\end{proof}

\begin{mydef}
	Let $\equiv$ a equivalence relationship over $\B$ we say that $\equiv$ is $\cR$ compatible if its $\cA$ compatible and $\forall p \in \cP$ and $\forall \bv \in \cV$ we have 
	$$\forall \ba_1,\ba_2 \in \cA, \ba_1 \equiv \ba_2 \implies r_p(\bv,\ba_1) = r_p(\bv,\ba_1)$$
\end{mydef}

\begin{myprop}
	Let $p \in \cP$, and $\equiv$ a $\cR$ compatible equivalence relationship over $\B$ then the function $r_p^\equiv : \cV^\equiv \times \cA^\equiv \rightarrow \mathbb{R}$ such that :
	$$r_p^\equiv(\bv^\equiv,\ba^\equiv,) = r_p(\bv,\ba) \mbox{ where : } \bv\in \bv^\equiv \mbox{ and } \ba \in \ba^\equiv $$
	is well defined.
\end{myprop}
\begin{proof}
	to do.
\end{proof}

\begin{myprop}
	Let $\equiv$ a $\cR$ compatible equivalence relationship over $\B$ then $\Gamma^\equiv = (\cP,\cA^\equiv,\cV^\equiv,\cR^\equiv,\pr^\equiv)$ is a well defined infinite stochastic game.
\end{myprop}

\begin{proof}
	immediate.
\end{proof}

